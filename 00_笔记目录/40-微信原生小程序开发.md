# 微信小程序

[微信](https://baike.baidu.com/item/微信/3905974)小程序，简称[小程序](https://baike.baidu.com/item/小程序)，英文名Mini Program，是一种不需要下载安装即可使用的[应用]

## 小程序概念

小程序没有DOM对象，一切基于组件化

**小程序的四个重要的文件**

~~~
*.wxml ---> view结构 ----> html
*.wxss ---> view样式 -----> css
~~~

## 小程序适配

Iphon6： 1rpx = 1物理像素 = 0.5px

**微信官方提供的换算方式：**

~~~
1.以iPhone6的物理像素个数为标准: 750;
2.1rpx = 目标设备宽度 / 750 * px;
3.注意此时底层已经做了viewport适配的处理，即实现了理想视	口
~~~

## 小程序工具构建目录架构

~~~
-pages				主要编写页面目录
-utils	  		工具目录
-app.js   		注册小程序js
-app.json			小程序全局配置
-app.wxss 		基本样式
-probject.config.json		项目配置文件
sitemap.json		迷
~~~

# 小程序标签组件

### 基本组件

~~~html
<view><!-- 块级元素 --></view>
<image src=""><!-- 图片元素 --></image>
<text><!-- 行内元素 --></text>
<web-view><!-- 承载网页, 自动铺满屏幕 --></web-view>
~~~

### 表单组件

~~~html
<button><!-- 按钮 --></button>
<switch><!-- 开关 --></switch>
<slider><!-- 滑动进度条 --></slider>
<checkbox-group>
  <!-- 多项选择容器 -->
	<checkbox><!-- 多项项目 --></checkbox>
</checkbox-group>
<radio-group>
  <!-- 单项选择容器 -->
	<radio><!-- 单项项目 --></radio>
</radio-group>
~~~

### 媒体组件

~~~html
<camera><!-- 系统相机 --></camera>
<live-player><!-- 音视频直播 --></live-player>
<live-pusher><!-- 音视频录制 --></live-pusher>
<video><!-- 音视频播放 --></video>
<map><!-- 地图 --></map>
<canvas><!-- 画布 --></canvas>
~~~

### 开放组件

~~~html
<ad><!-- 广告 --></ad>
<official-account><!-- 公众号关注 --></official-account>
~~~

# 小程序基本语法API

## 事件绑定

~~~html
<!-- bind冒泡事件 -->
<view bind:tap="myEventCallBack">点击</view>
<!-- catch阻止冒泡事件 -->
<view catch:tap="myEventCallBack">点击</view>
<!-- mut-bind阻止冒泡事件 -->
<view mut-bind:tap="myEventCallBack">点击</view>
~~~

~~~js
Page({
  myEventCallBack(ev){
    console.log(ev)
  }
})
~~~

**事件传参**

~~~html
<view bind:tap="myEventCallBack"  data-id='{{item.id}}'>点击</view>
~~~

~~~js
Page({
  myEventCallBack(ev){
    // 点击当前整体元素
    const id = ev.currentTarget.dataset.id
    
  }
})
~~~

**事件委派**

~~~html
<view bind:tap="myEventCallBack">
	<view data-id="0">子元素A</view>
</view>
~~~

~~~js
Page({
  myEventCallBack(ev){
    console.log(ev.target.dataset.id)
  }
})
~~~

## 大括号表达式

~~~html
<view> {{ message }} </view>
<image src="{{url}}"/>
<view style="display:{{fool?'block':'none'}}"></view>
~~~

## 列表渲染

~~~html
<view wx:for="{{array}}" wx:for-index="idx">
  {{index}}---{{item.message}}---{{idx}}
</view>
~~~

## 条件渲染

~~~html
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>
~~~

## 生命周期

~~~js
// 100-小程序基本编写/pages/list/list.js
Page({

	/* 页面的初始数据 */
	data: {
	},

	/**
	 * 生命周期函数--监听页面加载
	 */
	onLoad: function (options) {

	},

	/**
	 * 生命周期函数--监听页面初次渲染完成
	 */
	onReady: function () {

	},

	/**
	 * 生命周期函数--监听页面显示
	 */
	onShow: function () {

	},

	/**
	 * 生命周期函数--监听页面隐藏
	 */
	onHide: function () {

	},

	/**
	 * 生命周期函数--监听页面卸载
	 */
	onUnload: function () {

	},

	/**
	 * 页面相关事件处理函数--监听用户下拉动作
	 */
	onPullDownRefresh: function () {

	},

	/**
	 * 页面上拉触底事件的处理函数
	 */
	onReachBottom: function () {

	},

	/**
	 * 用户点击右上角分享
	 */
	onShareAppMessage: function () {

	}
})
~~~

![](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png)

# 全局对象wx

## 获取用户信息(按钮)

~~~js
// 判断用户是否已经授权
wx.getSetting({
  success: (result) => {
    const {authSetting} = result
    // 如果authSetting为true, 代表用户授权了
  }
})
// 获取用户信息：需要用户授权
wx.getUserInfo({
  success: (result)=>{},
});
myCallBack(data){
  const {userInfo} = data.mp.detail
  // 如果userInfo有值, 代表授权成功
}
}
~~~

~~~html
<button open-type="getUserInfo" bindgetuserinfo="myCallBack">用户信息授权</button>
~~~

## 本地储存

~~~js
// 异步:设置&添加 | 获取
wx.setStorage({key:'id',data:6})
wx.getStorage({key:'id',success,fail,complete})
wx.getStorageInfo({success,fail,complete})
// 同步:设置&添加
wx.setStorageSync({key:'id',data:6})
wx.getStorageSync('key')
wx.getStorageInfoSync()
~~~

# 路由页面编程

~~~html
<button bind:tap="goToListPage">点击跳转</button>
<!-- 或者 -->
<navigator url="/pages/index/index" >进入首页(tab页)</navigator>
<redirectTo url="/pages/index/index" >进入首页(tab页)</redirectTo>
~~~

~~~js
goToLlistPage () {
  // 点击跳转到list页面(不能跳转tapBar页面)
  // 推入栈
  wx.navigateTo({url:'/pages/list/list'})
  // 重定向
  wx.redirectTo({url:'/pages/list/list'})
  
  // 跳转tapBar页面(并关闭非tapBar页面)
  wx.switchTab({url: '/pages/list/list'});
}
~~~

## 路由传参

~~~js
// 父组件:传入index值为666
wx.navigateTo({url:'/pages/list/list?index=666'})
~~~

~~~js
onLoad: function (options) {
	const {index} = options // 666
},
~~~

## 设置底部路由导航

~~~js
// app.json
"tabBar": {
  "list": [ // 对应多个路由
    {	
      "pagePath": "pages/list/list", // 链接对应页面
      "text": "文与子",	// 链接文字
      "iconPath": "/images/tab/yuedu.png", // 链接未选中图片
      "selectedIconPath": "/images/tab/yuedu_hl.png" // 链接选中图片
    },
    {
      "pagePath": "pages/movies/movies",
      "text": "电影频道",
      "iconPath": "/images/tab/dianying.png",
      "selectedIconPath": "/images/tab/dianying_hl.png"
    }
  ]
}
~~~

# 小程序复用模板

#### **定义模板：**`pages/template/template.wxml`

~~~html
<template name="list_template">
<view class="list"><!-- 定义复用模板 --></view>
</template>
~~~

#### **定义模板样式：**`pages/template/template.wxss`

~~~css
.list{}
~~~

#### **引入模板：**`pages/list/list.wxml`

~~~html
<import src="/pages/template/template.wxml" /><!-- 引入 -->
<template is="list_template" /><!-- 使用 -->
~~~

#### **引入模板样式：**`pages/list/list.wxss`

~~~css
@import "/pages/template/template.wxss"
~~~

# 小程序自定义复用组件

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

## 定义组件

类似于页面，一个自定义组件由 `json` `wxml` `wxss` `js` 4个文件组成。要编写一个自定义组件，首先需要在 `json` 文件中进行自定义组件声明（将 `component` 字段设为 `true` 可将这一组文件设为自定义组件）：

~~~js
{ "component": true }
~~~

同时，还要在 `wxml` 文件中编写组件模板，在 `wxss` 文件中加入组件样式，它们的写法与页面的写法类似。

~~~html
<!-- 这是自定义组件的内部WXML结构 -->
<view class="inner">
 	{{innerText}}
    <slot><!-- 插槽是使用时, 传入的所有内容 --></slot>
</view>
~~~

~~~css
/* 这里的样式只应用于这个自定义组件 */
.inner {
  color: red;
}
~~~

在自定义组件的 `js` 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。
组件的属性值和内部数据将被用于组件 `wxml` 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 [Component构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html) 。

~~~js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
~~~



## 使用组件

使用已注册的自定义组件前，首先要在页面的 `json` 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径

~~~js
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
~~~

这样，在页面的 `wxml` 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

~~~html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
~~~

# app.js定义共用数据

~~~js
// app.js
App({
  data:{a:6}
})
// pages/index.js
const app = getApp()
console.log(app.data) // {a:6}
app.data.a = 7
console.log(app.data) // {a:7}
~~~

###### ###

# 小程序功能组件

## 提示框

~~~js
wx.showToast({title:'内容',icon: 'success'});
~~~

## 背景音乐播放器

https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html

~~~js
// 获取唯一后台播放器实例
const audioPlayer = wx.getBackgroundAudioManager()
// 设置音乐标题(必填)
audioPlayer.title = 'music'
// 设置音乐地址(必填)
audioPlayer.src = 'http://music.163.com/song/media/outer/url?id=1319688149.mp3'
// 设置音乐图片
audioPlayer.coverImgUrl = 'http://p1.music.126.net/oErHMKLK12jQbr7k6xrlMA==/109951164344700503.jpg?param=130y130'
// 设置音乐歌手名
audioPlayer.singer = 'Mr.A'
// 设置专辑名
audioPlayer.epname = 'OVA'
// 设置音频开始播放的时间
audioPlayer.startTime = 5
// 当前音频的长度（只读）
audioPlayer.duration
// 当前音频的播放位置（只读）
audioPlayer.currentTime
// 当前是否暂停或停止（只读）
audioPlayer.paused
// 播放/ 暂停
isMusicPlay ? audioPlayer.play() : audioPlayer.pause()
// 监视音频暂停
audioPlayer.onPause(()=>{})
// 监视音频播放
audioPlayer.onPlay(()=>{})
~~~

## 菜单栏

~~~js
wx.showActionSheet({
	itemList: ['分享到朋友圈', '分享到qq空间', '分享到微博'],
	success: (result) => {
		// 点击的下标
		const {tapIndex} = result
	}
})
~~~

## 点击分享(按钮)

~~~html
<button class="forward_button"  open-type="share">转发此文章</button>
~~~

# 发送ajax请求

~~~js
// 注意：默认不能使用http协议请求，需要在调试工具中关闭校验
var reqTask = wx.request({
	url: '', // 请求地址
	data: {}, // 请求参数
	header: {'content-type':'application/json'}, // 请求头
	method: 'GET', // 请求类型
	dataType: 'json', // 请求数据类型?
	responseType: 'text', // 返回数据类型?
	success: (result)=>{
		// 请求成功函数result 为结果
	},
	fail: ()=>{},
	complete: ()=>{}
});
~~~

###### ###