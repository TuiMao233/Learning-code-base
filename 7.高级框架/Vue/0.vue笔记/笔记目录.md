# Vue笔记目录

## 基础语法相关目录

- <a href="#Vue渐进式JS框架介绍与引入文件">Vue渐进式JS框架介绍与引入文件</a>
- <a href="#语法基本模板">语法基本模板</a>
- <a href="#计算属性与watch监视">计算属性与watch监视</a>
- <a href="#条件渲染,class绑定,style绑定">条件渲染,class绑定,style绑定</a>
- <a href="#列表渲染( for循环 ),列表增删改">列表渲染( for循环 ),列表增删改</a>
- <a href="#常用周期函数,常用指令,自定义标签属性">常用周期函数,常用指令,自定义标签属性</a>
- <a href="#Vue自定义插件定义与使用">Vue自定义插件定义与使用</a>

## Vue源码分析相关目录

- <a href="#Vue框架相关JS技术">Vue框架相关JS技术</a>
- <a href="#Vue框架技术点逻辑图">Vue框架技术点逻辑图</a>

## Vue脚手架相关目录

- <a href="#NPM模块包使用方式">NPM模块包使用方式</a>
- <a href="#脚手架安装与目录说明">脚手架安装与目录说明</a>
- <a href="#脚手架项目设置">脚手架项目设置</a>
- <a href="#组件间传输方式和消息发布与订阅">组件间传输方式和消息发布与订阅</a>
- <a href="#组件间传输slot标签">组件间传输slot标签</a>
- <a href="#路由组件定义与使用">路由组件定义与使用</a>

## Vuex相关目录

- #### `Vuex介绍大纲`

- #### `Vuex定义以及配置`

- #### `Vuex组件中使用方式`





## Vue渐进式JS框架介绍与引入文件

#### 1.vue的特点

- 遵循MVVM模式
- 编码简洁，体积小，运行效率高，适合移动/PC端开发
- 他本身只关注UI，可以轻松引入vue插件或其他库开发项目

#### 2.实践：input数据绑定p标签

1. 引入Vue.js

```html
<script src='js/vue.js'></script>
```

2. 创建Vue对象
   - el：指定跟element（选择器）
   - data：初始化数据（页面可以访问）

~~~html
// 创建Vue实例
<script>
	const vm = new Vue({
        el: '#box',
        data: {
            message: 'Hello Vue'
        }
    })
</script>
~~~

3. 双向数据绑定：v-model
4. 显示数据：{{xxx}}

~~~html
<div id="box">
	<input type="text" v-model="message" />
	<p>
	  Hello	{{message}}
	</p>
</div>
~~~

<div STYLE="page-break-after: always;">



#### 3.使用vue开发者工具调试（vue-devtools谷歌插件）


![调试工具](D:/u盘备份/1-前端/6.Vue/Vue核心/0.vue笔记/1.基础语法/img/TSGJ.jpg)

#### 4.理解Vue的MVVM

```sequence
title:MVVM模型
Note left of View: DOM
View->DOM Listeners:访问监听器(get,set)
DOM Listeners->Model(obj):查找数据
note over DOM Listeners,Data Bindings:ViewModel
Model(obj)->Data Bindings:数据绑定调用
Data Bindings-->View:进行DOM绑定监听数据
```

#### 5.MVVM内容

- View：视图，模板页面
- Model：模型，数据对象(data)
- ViewModel：视图模型(vue的实例)

</div>





## 语法基本模板

#### 1.模板的理解

- 动态的html页面，包含了一些JS语法代码
  - 双括号表达式
  - 指令（以V-开通的自定义标签属性）

##### 基本模板

~~~html
<div id="app">
	<p>{{msg}}</p>			        <!-- I Will Back!! -->
	<p>{{msg.toUpperCase()}}</p>     <!-- 嵌套js代码：全部大写 -->
	<p v-html="msge"></p>			<!-- innerHTML -->
	<p v-text="msge"></p>			<!-- innerText -->
</div>
~~~

~~~javascript
ew Vue({
	el:"#app",
	data:{
		msg:"I Will Back!!",
		msge:"<a href='http://www.baidu.com'>I Will Back!!</a>"
	}
})
~~~

##### 指令强制数据绑定

- 功能：指定变换的属性值
- 完整写法：`v-bind:xxx='yyy'` yyy会被作为表达式解析执行
- 简洁写法：`:xxx='yyy'`

~~~html
<div id="app">
	<img src="imgUrl" /><br />	        <!-- 报错 -->
	<img v-bind:src="imgUrl" /><br />	<!-- 显示 -->
	<img :src="imgUrl" />            	<!-- 显示 -->
</div> 
~~~

~~~javascript
ew Vue({
	el:"#app",
	data:{
		imgUrl:https://cn.vuejs.org/images/logo.png  
	 }
})
~~~

<div STYLE="page-break-after: always;">


#### 2.指令绑定时间监听

- 完整写法：`v-on:click='fun'` fun是Vue实例定义的方法
- 简洁写法：`@click='fun'`

~~~html
<div id="app">
	<button v-on:click="test">点击</button>
	<button @click="test('abc')">点击</button>
</div>
~~~

~~~javascript
new Vue({
	el:"#app",
	methods:{
		test(a) {
			a.isTrusted ? alert("我没传入形参啦") : alert(a);;
		}
	}
})
~~~

</div>





## 计算属性与watch监视

#### 1.在computed属性对象中定义计算属性的方法

~~~html
<div id="demo">
	姓：<input type="text" v-model="firstName"/><br />
	名：<input type="text" v-model="lastName"/><br />
	姓名(单向)：<input type="text" v-model="Name" />
</div>
~~~

~~~javascript
new Vue({
	el: "#demo",
	data:{
		firstName: 'Aaa',
		lastName: 'bbbB'
	},
	computed:{
		name (){
			//什么时候执行:初始化显示/相关的data属性数据发生了改变
			return this.firstname + " " + this.lastname 
		}
	}
})
~~~

#### 2.watch监视firstName和lastName

~~~html
<div id="demo">
	姓：<input type="text" v-model="firstName"/><br />
	名：<input type="text" v-model="lastName"/><br />
	姓名(单向)：<input type="text" v-model="name" /><!--firstName + lastName-->
</div>

~~~

##### watch内部监视

- ~~~javascript
  new Vue({       
  el: "#demo",
  		data:{
  			firstName: 'Aaa',
  			lastName: 'bbbB',
  			name: ''
  		},
  		watch:{ // 内部监视
  		firstName: function (value){ // 当firstName值改变时执行,初始化不会执行
  			this.funllname = value + ' ' + this.lastname
  		}
  })
  ~~~

  <div STYLE="page-break-after: always;">

##### watch外部监视

- ~~~javascript
  vm.$watch('lastName',function(newVal){ // 当lastName值改变时执行,初始化不会执行
  	this.funllName = this.firstName + ' ' + newVal    
   })
  ~~~

#### 3.监视input读取和写入

~~~html
<div id="demo">
	姓：<input type="text" v-model="firstName"/><br />
	名：<input type="text" v-model="lastName"/><br />
	姓名(双向)：<input type="text" v-model="name" /><!--firstName + lastName-->
</div>
~~~

##### computed对象函数监视属性的get和set

- ~~~javascript
  new Vue({
  	em: "#demo",
  	data:{		//数据(model)
  		firstname: 'Aaa',
  		lastname: 'bbbB',
  	}, 
  	computed:{
  		funllname: {
  	// 回调函数,当需要读取当前属性值时回调,根据相关的数据计算并返回当前属性的值
  			get(){
  				return this.firstname + "|" + this.lastname
  			},
  			// 回调函数,当属性值发生改变时回调,更新相关的属性数据
  			set(value){// value就是funllname的最新属性值
  				var names = value.split("|")
  				names.length == 1 ? names[1] = ":" : []
  				this.firstname = names[0]
  				this.lastname = names[1]
  			}
  		},
  	}
  })
  ~~~

</div>





## 条件渲染,class绑定,style绑定

### 标签判断是否显示

#### 1.条件渲染指令

- `v-if`
- `v-else`
- `v-show`

#### 2.比较v-if与v-show

- 如果一些不怎么切换的地方用v-if `因为隐藏的元素会直接去除`
- 如果需要频繁切换的使用v-show `因为隐藏的元素会加上display: none;而不是直接去除`

#### 3.绑定字符串

~~~html
<style>
    .aClass{color:#0000FF;}
</style>
<div id="demo">
	<p v-if="ok">成功了</p>
	<p v-else>失败了</p>
    <!-- 或者是下面代码 -->
    <p v-show="ok">表白成功</p>
	<p v-show="!ok">表白失败</p>
	<button @click="ok=!ok">点击</button>
</div>
~~~

~~~javascript
var vm =new Vue({
	el:'#demo',
	data:{
		ok:false
	}
})
~~~

<div STYLE="page-break-after: always;">


### class绑定与style绑定

- 在应用界面中，某个（些）元素的样式是变化的
- class/style 绑定就是专门用来实现动态样式效果的技术
- 在 Vue 的 methods 可利用事件绑定函数对 class 和 style 改变


#### 1.绑定字符串

~~~html
<style>
    *{margin: 0;padding: 0;}
	.aClass{color: blue; }
	.cClass{color: red; }
</style>
<div id="demo">
	<p class="cClass" :class="text">xxx是字符串</p>
	<button @click="classEco">点击更改class</button>
</div>
~~~

~~~javascript
var vm =new Vue({
	el:"#demo",
	data:{ 
		text:'aClass'
	},
	methods:{
		classEco(){
			this.text = 'bClass'
		}
	}
})
~~~

#### 2.绑定数组

~~~html
<style>
	.aClass{color: blue; }
	.bClass{background: red; }
</style>
<div id="demo">
		<p :class="['aClass','cClass']">xxx是数组</p>
</div>

~~~

</div>

<div STYLE="page-break-after: always;">


#### 4.绑定对象，以及绑定公用class

~~~html
<style>
	.aClass{color: blue; }
	.bClass{color: red; }
	.cClass{font-size: 30px;line-height: 50px;}
</style>
<div id="demo">
	<p class="cClass" :class="{aClass:isA,bClass:isB}">xxx是对象</p>
</div>
~~~

~~~javascript
var vm =new Vue({
	el:"#demo",
	data:{
		isA:true,
		isB:false
	},
	methods:{
		classEco(){
			this.isB=true
			this.isA=false
	}}
})
~~~

#### 5.绑定对象

~~~html
<div id="demo">
	<p :style="{color:ftCol,fontSize:ftSz +'px'}">style绑定</p>
	<button @click="classEco">点击更改style</button>
</div>
~~~

~~~javascript
var vm =new Vue({
	el:"#demo",
	data:{
		ftCol:'red',
		ftSz:20
	},
	methods:{
		classEco(){
			this.ftCol='green'
			this.ftSz=60
		}
    }
})
~~~

</div>





## 列表渲染( for循环 ),列表增删改

### 列表渲染指令

#### 1.列表循环：v-for / index

##### html 语法

- ~~~html
  <p v-for="(w,index) in persons" >		<!--  每次都会遍历并执行一遍  -->
  		{{index}}---{{w.name}}---{{p.age}}    
  <p>
  ~~~

- **w：**`是标识,标识遍历persons`

- **index：**`是数组的序号`

- **persons：**`是vue对象内的一个数组`

##### Javascript 语法

- ~~~javascript
  var vm = new Vue({
      el: '#demo',
      date: {
          persons: [
  			{name: 'Tom', age:18},
  			{name: 'Jack', age:17},
  			{name: 'Bob', age:19},
  			{name: 'Mary', age:16}
          ]
      }
  })
  ~~~

#### 2.for循环的 :key='xxx'

- 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：

  - ~~~html
    <div v-for="item in items" v-bind   :key="item.id">
         <!-- 内容 -->
    </div>
    ~~~

- 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。

> 不要使用对象或数组之类的非基本类型值作为 v-for 的 key。要用不一样的字符串或数值类型的值。

<div STYLE="page-break-after: always;">


#### 3.列表数组的增删改

~~~html
  <div id="demo">
  	<ul>
   		<li v-for="(p,index) in persons" :key="item.id" >
			{{index}}---{{p.name}}---{{p.age}}
			---<button @click="deletP(index)">删除</button>
			---<button @click="undataP(index,{name:'Cat',age:20})">更新</button>
   		</li>
  	</ul>
 	<button @click="">添加</button>
</div>
~~~

- vue只是监视了persons的改变，没有监视数组内部属性的改变
- vue重写了数组中的一系列改变数组内部数据的方法
  - (先调用元素，更新界面) > 使用变异数组内部方法 > 数据绑定 > 页面变化

~~~javascript
var vm = new Vue({
el: '#demo',
    data: {
      persons: [
        {name: 'Tom', age:18},
        {name: 'Jack', age:17}
      ]
    },
    methods:{
		deletP(index){
			this.persons.splice(index,1) 
		},
		undataP(index,obj){
			this.persons.splice(index,1,obj)
		}
	}
})
~~~

</div>





## 常用周期函数,常用指令,自定义标签属性

### Vue生命周期分析

#### 1.初始化显示可调用函数

- `beforeCreate()`
- `created()`
- `beforeMount()`
- `mounted()`

#### 2.更新状态可调用函数：this.xxx = value

- `beforeUpdate()`
- `updated()`

#### 3.销毁Vue实例可调用函数：vm.$destory()

- `beforeDestory()`
- `destoryed()`

#### 4.一般比较常用的生命周期方法

- `created()/mounted()`: 发送ajax请求, 启动定时器等异步任务
- `beforeDestory()`: 做收尾工作, 如: 清除定时器

#### 5.常用内置html指令

1. `v-text`：更新元素的textContent
2. `v-html`：更新元素的innerHTML
3. `v-if`：如果为true, 当前标签才会输出到页面
4. `v-else`：如果为false, 当前标签才会输出到页面
5. `v-show`：通过控制display 样式来控制显示/隐藏
6. `v-for`：遍历数组/对象
7. `v-on`：绑定事件监听, 一般简写为@
8. `v-bind`：强制绑定解析表达式, 可以省略v-bind
9. `v-model`：双向数据绑定
10. `ref`：指定唯一标识, vue 对象通过$els 属性访问这个元素对象
11. `v-cloak`：防止闪现, 与css 配合: [v-cloak] { display: none }

### Vue自定义标签属性

#### 1.注册全局

- ~~~javascript
  Vue.directive('upper-text', function(el, binding){
      el.innerText = binding.value.toUpperCase() // 全部转为大写
  })
  ~~~

<div STYLE="page-break-after: always;">


#### 2.注册局部

- ```javascript
  new Vue({
  	el:'#test',
  	data:{
          msg2:'Dzl SB?,,,,Yes!!'
  	},
  	directives:{ // 注册局部指令:只在当前vm管理范围有效
  		'upper-text':function(el,binding){
  			el.innerText=binding.value.toLowerCase()// 全部转为大写
  		}
  	}
  })
  ```

  - 'my-directive'` 是自定义标签属性名，这个值可以是任何值` 
  - `el` 是调用此方法的 html 标签
  - `binding` 是这个标签所包含的内容

#### 3.如何使用

~~~html
<div id="test">
	<p v-upper-text='msg'> </p>
</div>
~~~

</div>





### Vue自定义插件定义与使用

#### 1.vue-myPlugin.js ( 自定义插件名称 )的定义

- ```javascript
  /* vue的插件库 */
  (function(window){
  	// 需要向外暴露的插件对象
  	const Muplugin = {}
  	// 插件对象必须有一个install()
  	Muplugin.install = function (Vue, options) {
  		//1.添加全局方法或属性
  		Vue.ZdyWenFun = function (x){
  			console.log(x)
  		}
  		//2.添加全局资源--->标签名 v-my-upper
  		Vue.directive('my-upper',function(el,binding){
  			el.innerText = binding.value.toUpperCase()
  		})
  		//3.添加实例方法
  		Vue.prototype.$myMethod = function(){
  			console.log('我tm是实例方法')
  		}	
  	}
  	Vue.use(Muplugin) // 内部进行调用解析插件对象的install()
  })(window)
  ```

#### 2.JavaScript代码中调用

- ```html
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript" src="js/vue-myPlugin.js"></script>
  <script type="text/javascript">
    const vm = new Vue({
      el: '#test',
      data: {
        msg: 'i LOve U'
      },
  	mounted() {//添加的实例方法
  		this.$myMethod()
  	}
    })
    // 添加的全局方法 可以在任何地方调用
    Vue.ZdyWenFun('全局方法阿nmd');
    // 添加的实例方法 只能在当前的vm实例中调用
    vm.$myMethod()
  </script>
  ```





## Vue框架相关JS技术

#### 1.伪数组转换为真数组

- ~~~html
  <li>test1</li><li>test2</li><li>test3</li>
  <script>
      const lis = document.querySelectorAll('li') // 这是一个伪数组 {0:li, 1:li....}
  	const lisAll = Array.prototype.slice.call(lis) // ES5 [0:li, 1:li....]
  	const lisAll2 = Array.from(lis) // ES6 [0:li, 1:li....]
  </script>
  ~~~

#### 2.获取节点类型

- ~~~javascript
  const el = document.getElementById('test') // 获取元素节点
  const attrNode = el.getAttributeNode('id') // 获取标签节点
  const textNode = el.firstChild // 获取文本节点
  console.log(el.nodeType, attrNode.nodeType, textNode.nodeType)
  // 元素节点返回 1 标签节点返回 2 文本节点返回 3
  ~~~

#### 3.对象属性可设置数据描述符和存取描述符

- ~~~javascript
  语法：Object.defineProperty(obj  ,  prop , { descriptor })
  obj： 要在其上定义属性的对象。
  prop：要定义或修改的属性的名称。
  descriptor：将被定义或修改的属性描述符。
  ~~~

#### 4.defineProperty数据绑定数据同步

- ~~~javascript
  const obj = { firstName: 'A', lastName: 'B' }
  // 给obj添加一个 fullName 其绑定firstName和lastName的数据
  Object.defineProperty(obj, 'fullName', {
      // 当读取时值是firstName + '-' + lastName
  	get: function () {
  		return this.firstName + '-' +this.lastName
  	},
      // 当修改时分割-字符串在把两个的值给firstName和lastName
  	set: function (value) {
  		const names = value.split('-')
  		this.firstName = names[0]
  		this.lastName = name
          s[1]
  	}
  })
  ~~~

<div STYLE="page-break-after: always;">


#### 5.修改defineProperty方法数据描述符

- ~~~javascript
  Object.defineProperty(obj, 'fullName2', {
  	configurable: true, // 是否可修改
  	enumerable: true, // 是否可枚举
  	value: 'fullName2222' , // 初始值 可以是任何有效的javascript值
  	writable: false
  })
  ~~~

#### 6.得到对象自身可枚举属性名称字符串组成的数组

- ~~~javascript
  const ObjNames = Object.keys(obj)
  // ObjNames-->['firstName', 'lastName', 'fullName']
  ~~~

#### 7.判断prop是否是obj自身的属性( 判断是否为对象的属性 )

- ~~~javascript
  // 语法：obj.hasOwnProperty(prop)
  console.log(obj.hasOwnProperty('firstName'))
  ~~~


#### 8.DocumentFragment(高效批量更新多个节点)

- #### 利用documentFragment一次性修改所有li

  - ~~~html
    <ul>
    	<li>test1</li>
    	<li>test2</li>
    	<li>test3</li>
    </ul>
    <script>
        const ul = document.querySelector('ul')
        // 1. 创建fragment
        const fragment = document.createDocumentFragment()
        // 2. 取出ul中所有子节点取出保存到fragment
        let child
    	while (child = ul.firstChild) {
    		 fragment.appendChild(child)
    	}
        // 3. 更新fragment中的所有li文本
        Array.prototype.slice.call(fragment.childNodes).forEach(node => {
    		if (node.nodeType === 1) { // 过滤不是文本节点的节点
    			node.innerText = 'WWWW'
    		}
    	})
        // 4. 将fragment插入ul
        ul.appendChild(fragment)
    </script>
    ~~~

- **documentFragment**：内存中保存n个elment 的容器对象(不与界面关联)，用来存节点的容器，并且容器是在内存隔离的，不与外界发生关系

</div>





## NPM模块包使用方式

#### 1.NPM(Node Package Manager)

- CommonJS包规范是理论，NPM是其中一种实践。

- 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。

~~~
– 查看版本
	• npm –v
– 帮助说明
	• npm
– 查看所有模块的版本
	• npm version
– 搜索模块包
	• npm search 包名
–下载当前项目所依赖的包
	• npm install
– 在当前目录安装包
	• npm install 包名
– 全局模式安装包（全局安装的包一般都是一些工具）
	• npm install 包名 –g
– 删除一个模块
	• npm remove 包名
– 安装包并添加到依赖中
	• npm install 包名 –save    *******
– 从本地安装
	• npm install 文件路径
– 从镜像源安装
	• npm install 包名 –registry=地址
– 设置镜像源
   • npm config set registry 地址

~~~

#### 2.通过npm下载的包都放到node_modules文件夹中

~~~
我们通过npm下载的包，直接通过包名引入即可
node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块
如果有则直接使用，如果没有则去上一级目录的node_modules中寻找
如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止
直到找到磁盘的根目录，如果依然没有，则报错
~~~

#### 3.Node.js文件引入npm包

~~~javascript
// 语法：require('包名')
var math = require('math')
console.log(math.add(123,456))
~~~

#### 4.Vue引入npm包

~~~javascript
// 语法：xxx 
import xxx = 'xxx'
~~~





## 脚手架安装与目录说明

#### 1.安装

1. **安装vue：**npm install vue –g
2. **安装路由：**npm install vue-router -g
3. **安装vue脚手架：**npm install vue-cli –g

#### 2.使用：

在cmd目录下搭建环境vue init

~~~
vue init webpack {项目名字} ---->
Project name {文件名} 				[，是否为项目名,默认是]
Project description {项目描述}
Author {作者名,邮箱地址}
Vue build {打包工具名字??}
Install vue-router? {Y/n}   					[，是否安装路由 ]
Use ESLint to lint your code {Y/n}      		[，是否使用ESLint管理代码 ]
Pick an ESLint preset (Use arrow keys) {Y/n}		[，选择一个ESLint预设 ]
Setup unit tests with Karma + Mocha? {Y/n}		[，是否安装单元测试 ]
Setup e2e tests with Nightwatch(Y/n)? 		[，e2e测试 ]

~~~

操作方法

~~~
npm run dev 打包并开启服务
npm run build	生成静态文件
~~~

> .config 文件夹 --> index.js --> autoOpenBrowser : true  是否自动打开浏览器 

<div STYLE="page-break-after: always;">


## vue 脚手架项目目录文件说明

#### vue_cli_demo-master--> (vue项目总文件夹)

~~~
- Build 			webpack相关配置
- config	 		vue基本配置文件(监听端口，打包输出等相关配置)
- node_modules		用node安装的依赖包
- src				资源文件夹以后我们就在这个目录写代码
- static			静态资源(图片之类)json数据之类
- test				单元测试,代码测试
- .babelrc			ES6语法编译配置,依赖将es6代码转换为浏览器识别的代码
- .editorconfig		定义代码格式
- .gitignore		上传需要忽略的文件格式
- .postcssrc.js		转换css工具
- index.html		页面入口
- npm-debug.log		npm相关log信息
- package.json		项目基本信息(项目开发所需模块,项目名称,版本)
- readme.md			项目说明(如何使用,有哪些方法等等)

~~~

#### src目录下文件--- >  (vue基本配置文件)

~~~
- assets		    静态资源(js,css之类可以放在这下面)
- components	    公用组件编写的地方
- App.vue		    项目的主组件,所有页面都是在app.vue下切换的.一个标准的vue文件,分为三部分。
- main		    	页面程序入口文件,加载各种公共组件
~~~

#### Build目录下文件--- >  (webpack相关配置)

~~~
- Build.js		       生产环境构建代码
- check-versions.js     检查node、npm等版本
- dev-client.js		   热重载相关
- dev-server.js		   构建本地服务器
- utils.js			   构建工具相关
- vue-loader.conf.js  	css加载器配置
- webpack.base.conf.js	webpack基础配置
- webpack.dev.conf.js	webpack开发环境配置
- webpack.prod.conf.js	webpack生产环境配置
- webpack.test.conf.js	测试相关配置
~~~

#### config目录下文件--- > (vue基本配置文件)

~~~
- dev.env.js	开发环境变量
- index.js		项目一些配置变量
- prod.env.js	生产环境变量
- test.env.js	测试环境变量
~~~

</div>





## 脚手架项目设置

### 开启发布打包项目与修改发布打包名称

#### 1.项目打包

~~~
npm run build
~~~

#### 2.静态服务器工具包

~~~
安装：npm install -g serve   
开启dist包文件夹：serve dist
访问: http://localhost:5000
~~~

#### 3.修改打包项目名称并开启打包项目

修改配置 webpack.prod.conf.js

~~~
output: {
	publicPath: '/xxx/' //打包文件夹的名称
}
~~~

使用动态web服务器（tomcat）开启打包项目

~~~
npm run build // 重新打包
修改dist 文件夹为项目名称: xxx
将xxx 拷贝到运行的tomcat（后端服务） 的运行目录下
访问: http://localhost:8080/xxx
~~~

### eslint 代码规范检测工具

- 它定义了很多特定的规则, 一旦你的代码违背了某一规则, `eslint` 会作出非常有用的提示
- EsLint的检测范围有`ES`，`JSX`，`Style`。还可以自定义错误和提示
- 规则的错误等级有三种：
  - 0：关闭规则。
  - 1：打开规则，并且作为一个警告（信息打印黄色字体）
  - 2：打开规则，并且作为一个错误（信息打印红色字体）

<div STYLE="page-break-after: always;">


### Vue脚手架 入口函数src/main.js配置

~~~javascript
/* src/main.js */
import Vue from 'vue'     	 //创建vue实例
import App from './App.vue'  //引入主要组件
var vm = new Vue({
 	el: '#app',				//选择ID为app的元素
	components: {App},		//映射组件为标签
 	 template: '<App />'		//app元素内部添加映射标签<App />
})
~~~

### vue 组件的定义和使用

#### 1.组件模块方式（App.vue）：

~~~html
<!-- 模板页面(内容必须用div包裹) -->
<template>
	<div></div>
</template>
<!-- JS 模块对象 -->
<script>
	export default {
		data() {return {}},
		methods: {},
		…………
	}
</script>
<!-- 样式定义 -->
<style>
</style>
~~~

#### 2.App.vue引入其他组件使用方式：

~~~html
	<template>
	<HelloWorld></HelloWorld>		<!-- 3- 使用组件标签 -->	
	<hello-world />					<!-- 3- 使用组件标签 -->
	</template>
	<script>
	import HelloWorld from './components/HelloWorld'     /* 1- 引入组件 */
	export default {
	components: {
		HelloWorld        /* 2- 映射成标签 */
		}
	}
	</script>
~~~

</div>





## 组件间传输方式和消息发布与订阅

### 标签传输

#### 1.利用标签名从父组件传输数据到子组件

~~~html
<!-- 父组件标签(App.js)传输数据(任意JS属性或方法) -->
<TdoHead  :addTask='addTask' /> 
~~~

~~~html
// 子组件(components/...js)props接收数据 
<script>
 const vm = new Vue({
     props: { addTask: Function }
 })
</script>
~~~

#### 2.利用自定义标签从父组件标签直接传输数据到子组件

~~~html
<!-- 父组件标签(App.js)传输数据(任意JS属性或方法) -->
<TdoHead  @addTask='addTask' /> 
~~~

~~~javascript
/* 子组件(components/...js)利用$emit方法接收(?)或使用数据 */
     methods: {
      sumTask () { 
		// 使用自定义事件,this.$emit('事件名', [,传入的形参])
         this.$emit('addTask', task)
      }
 	}
~~~

#### 3.父组件利用子组件标签传递事件

~~~javascript
/* 父组件异步传输数据 */
mounted () { // 给<TdoHead>添加名为addTask的事件 并传入数据(方法)
      this.$refs.header.$on('addTask', this.addTask)
}
~~~

~~~javascript
/* 子组件(components/...js)利用$emit方法接收(?)或使用数据 */
methods: {
	sumTask () {
		//使用自定义事件,this.$emit('事件名', [,传入的形参])
		this.$emit('addTask', task)
	}
}
~~~

<div STYLE="page-break-after: always;">


### Vue利用window.localStorage保存与读取缓存

#### 1.读取缓存并转换为 JS 数组  并保存到Vue数据

~~~javascript
data () {    
	return {
	    // 取JSON数据并转换为js数组,如果空则返回空数组
		Task: JSON.parse(window.localStorage.getItem('todos_key') || '[]')
    }
},
~~~

#### 2.Vue监视数据并转换为JSON存入缓存

~~~javascript
watch: { Task: { // 监视Task
    deep: true, // 深度监视
	handler: function (value) {
		// 将Task最新的值，转换为JSON保存到localStrorage缓存中
		window.localStorage.setItem('todos_key', JSON.stringify(value))
	}
}},
~~~

### Vue消息订阅发布

#### 1.项目安装 pubsub 消息系统（信息中介）

~~~
npm install –save pubsub-js   -->安装
npm info pubsub-js	-->查看信息
~~~

#### 2.Vue组件引入并使用pubsub

###### pubsub可在Vue组件任意地方传输数据

1. **引入 pubsub** 

   - ~~~javascript
     import PubSub from 'pubsub-js'
     ~~~

2. **发布消息**`任意组件发布消息数据`

   - ~~~javascript
     // data 任何js属性或方法
     PubSub.publish('消息名', data)
     ~~~

3. **订阅消息**`任意组件订阅消息数据`

   - ~~~javascript
     // PubSub.subscribe 当publish方法调用并消息名一致时执行
     PubSub.subscribe('消息名', (msg, data)=>{})
     ~~~

</div>





## 组件间传输slot标签

#### 1.父组件利用子组件标签传入实体标签

~~~html
<!-- 传入子组件需要的标签 -->
<子组件标签> 
	<div slot="xxx">xxx 对应的标签结构</div>
	<div slot="yyy">yyy 对应的标签结构</div>
</子组件标签> 
~~~

#### 2.子组件使用父组件传入的标签输出标签

~~~html
<!-- 输出父组件标签 -->
<div>
	<slot name="xxx">父组件对应xxx的标签结构</slot>
	<div>组件确定的标签结构</div>
	<slot name="yyy">父组件对应yyy的标签结构</slot>
</div>
~~~







## Vue-ajax与vue-resource的安装与使用

~~~
/* 安装vue-resource */
cnpm install vue-resource --save
/* 安装axios */
cnpm install axios --save
~~~

#### 1.vue-axios使用：

- ~~~javascript
  // 在需要使用的组件内引入axios
  import axios from 'axios'
  // 使用axios发送ajax请求获取数据
  axios.get(url).then(axioData => {
      console.log(axioData.data)
  }).catch(axioErrorData => {
      console.log(axioErrorData.data)
  })
  ~~~

<div STYLE="page-break-after: always;">


#### 2.vue-resource使用：

- ```javascript
  /* Main.js入口函数设置 */
  import Vue from 'vue'
  import App from './App.vue'
  import VueRouter from 'vue-resource' 
  Vue.use(VueRouter)
  var vm = new Vue({ el: '#app', components: { App }, template: '<App/>' })
  ```

- ```javascript
  /* App.vue实例中使用  */
  mounted () { 
      // 入口函数设置后Vue实例会自带一个$http对象
  	this.$http.get(url).then(
     		// 获取成功则调用这个函数
     		resourData => { console.log(axioData.data) },
     		// 获取失败则调用这个函数
     		resourErrorData => { console.log(resourErrorData.data) }
  	)
  }
  ```

</div>





## 路由组件定义与使用

### Vue-Router页面路由组件

Vue Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。（大概）

#### 1.定义（路由）组件，路由组件装载着需要的内容

通常这类组件放在 *src/views* 文件夹内`(a.vue b.vue)`

#### 2.定义路由，模块化路由器，并配置路由组件

~~~javascript
// src/rouder/index.js：
import Vue from 'vue' 
import VueRouter from 'vue-router'  
import About from '../views/a.vue'
import Home from '../views/b.vue'
Vue.use(VueRouter) 
export default new VueRouter({   /* 这里定义路由 */
	linkActiveClass: 'active', // 定义默认路由类名
	routes: [{ path: '/about', component: About }, // 配置路由组件
    		 { path: '/home', component: Home },
              { path: '/', redirect: '/about' } ]
})
~~~

#### 3.Vue-cli入口函数引入路由

~~~javascript
import Vue from 'vue'
import App from './App.vue'
import router from './router'
const app = new Vue({
	components: { App },
	template: '<App/>',
	router
}).$mount('#app')
~~~

#### 4.在页面组件使用路由组件（App.vue或其他组件）

~~~html
<div id="app">
	<router-link to="/about">Go to about</router-link>
	<router-link to="/home">Go to home</router-link>
	<router-view> </router-view>
</div>
~~~

![1574341010](C:\Users\Administrator\Desktop\vue笔记\三、vue脚手架\img\1574341010.png)

#### 5.组件实例访问路由器或访问当前显示路由

~~~javascript
mounted () {
	console.log(this.$route) // 当前显示路由
	console.log(this.$router) // 路由器
}
~~~

#### 6.路由组件缓存（可让显示路由保存值和自身，在刷新页面时或重新启动浏览器(?)不会消失）

~~~html
<keep-alive> <!-- 利用keep-alive标签包裹显示路由 -->
	<router-view class="w"></router-view>
</keep-alive>
~~~

#### 7.路由链接传值

1. **定义一个可通过链接传值路由（src/rouder/index.js）**

   - ~~~javascript
     // 引入
     import Home from './Home.vue'
     // 路由配置
     roates: [{ path: '/home/:id', commponent: Home }]
     ~~~

2. **任意组件方法利用 `router.push`改变路径（app.vue）**

   - ~~~javascript
     pushShow (id) { this.$router.push('/home/${id}') }
     ~~~

3. **监视当前显示路由尾数`'id'`的变化而改变路由组件（home路由）**

   - ~~~javascript
     watch: { $route: function (route) {
     	if (route.params.id) {
     		const id = route.params.id
     		// 从数据库中寻找有相同标识的数据并返回
     		this.logoData = this.userData.find(user => id === user.id)
     	}
     } }
     ~~~



