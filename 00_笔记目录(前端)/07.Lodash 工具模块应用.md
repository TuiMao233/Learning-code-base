## Lodash 简介

Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。

Lodash 遵循 MIT 开源协议发布，并且支持最新的运行环境。 查看各个构件版本的区别并选择一个适合你的版本。

### 安装

浏览器环境：

~~~html
<script src="lodash.js"></script>
~~~

通过 npm：

~~~makefile
$ npm i -g npm
$ npm i --save lodash
~~~

Node.js：

~~~js
// Load the full build.
var _ = require('lodash');
// Load the core build.
var _ = require('lodash/core');
// Load the FP build for immutable auto-curried iteratee-first data-last methods.
var fp = require('lodash/fp');
 
// Load method categories.
var array = require('lodash/array');
var object = require('lodash/fp/object');
 
// Cherry-pick methods for smaller browserify/rollup/webpack bundles.
var at = require('lodash/at');
var curryN = require('lodash/fp/curryN');
~~~

### 为什么是 Lodash ？

Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法 非常适用于：

- 遍历 array、object 和 string
- 对值进行操作和检测
- 创建符合功能的函数

### 补充工具

- [futil-js](https://github.com/smartprocure/futil-js) 是一套用来补足 lodash 的实用工具集。

## 数组类方法 

### 数组分割（chunk）

将数组（array）拆分成多个 `size` 长度的区块，并将这些区块组成一个新数组。 如果`array` 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。

~~~js
_.chunk(['a', 'b', 'c', 'd'], 2);
// => [['a', 'b'], ['c', 'd']]
 
_.chunk(['a', 'b', 'c', 'd'], 3);
// => [['a', 'b', 'c'], ['d']]
~~~

### 过滤非真值（compact）

创建一个新数组，包含原数组中所有的非假值元素。例如`false`, `null`,`0`, `""`, `undefined`, 和 `NaN` 都是被认为是“假值”。

~~~js
_.compact([0, 1, false, 2, '', 3]);
// => [1, 2, 3]
~~~

### 值与数组链接（concat）

创建一个新数组，将`array`与任何数组 或 值连接在一起。

~~~js
var array = [1];
var other = _.concat(array, 2, [3], [[4]]);
 
console.log(other);
// => [1, 2, 3, [4]]
 
console.log(array);
// => [1]
~~~

### 对数组值进行过滤（difference）

创建一个具有唯一`array`值的数组，每个值不包含在其他给定的数组中。

~~~js
_.difference([3, 2, 1], [4, 2]);
// => [3, 1]
~~~

接收接受一个 `iteratee` （注：迭代器），调用`array` 和 `values` 中的每个元素以比较产生值。

~~~js
_.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
// => [3.1, 1.3]
 
// The `_.property` iteratee shorthand.
_.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
// => [{ 'x': 2 }]
~~~

接受一个 `comparator` （注：比较器），调用比较`array`，`values`中的元素。 结果值是从第一数组中选择。

~~~js
var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 
_.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
// => [{ 'x': 2, 'y': 1 }]
~~~

### 数组切片（drop）

创建一个切片数组，去除`array`前面的`n`个元素。（`n`默认值为1。）

~~~js
_.drop([1, 2, 3]);
// => [2, 3]
 
_.drop([1, 2, 3], 2);
// => [3]
 
_.drop([1, 2, 3], 5);
// => []
 
_.drop([1, 2, 3], 0);
// => [1, 2, 3]
~~~

创建一个切片数组，去除`array`尾部的`n`个元素。（`n`默认值为1。）

~~~js
_.dropRight([1, 2, 3]);
// => [1, 2]
 
_.dropRight([1, 2, 3], 2);
// => [1]
 
_.dropRight([1, 2, 3], 5);
// => []
 
_.dropRight([1, 2, 3], 0);
// => [1, 2, 3]
~~~

### 数组填充（fill）

使用 `value` 值来填充（替换） `array`，从`start`位置开始, 到`end`位置结束（但不包含`end`位置）。

~~~js
var array = [1, 2, 3];
 
_.fill(array, 'a');
console.log(array);
// => ['a', 'a', 'a']
~~~

代替方法（array.fill）

~~~js
var array = [1, 2, 3].fill('a')
console.log(array);
// => ['a', 'a', 'a']
~~~

### 数组降维（flatten）

减少一级`array`嵌套深度。

~~~js
_.flatten([1, [2, [3, [4]], 5]]);
// => [1, 2, [3, [4]], 5]
~~~

将`array`递归为一维数组。

~~~js
_.flattenDeep([1, [2, [3, [4]], 5]]);
// => [1, 2, 3, 4, 5]
~~~

根据 `depth` 递归减少 `array` 的嵌套层级

~~~js
var array = [1, [2, [3, [4]], 5]];
 
_.flattenDepth(array, 1);
// => [1, 2, [3, [4]], 5]
 
_.flattenDepth(array, 2);
// => [1, 2, 3, [4], 5]
~~~

替代方案（flat or flatMap）

~~~js
// flat: 将多维数组转换为低维数组
const arr = [1, 2, 3, 4, [5, 6, [7, 8, 9]]]
// 参数为转换深度, 是一个数字
console.log(arr.flat(2))

// flatMap: 遍历如果返回的是多维数组, 转换为低维数组
const arr = [1,2,3,4]
const result = arr.flatMap(item=> [item*10])
~~~

### 二维数组转换为对象（fromPairs）

根据二维数组返回一个由键值对`pairs`构成的对象。

~~~js
_.fromPairs([['fred', 30], ['barney', 40]]);
// => { 'fred': 30, 'barney': 40 }
~~~

代替方案（Object.fromEntries）

~~~js
const result = Object.fromEntries([
  ['name', '尚硅谷'],
  ['xueke', 'Java,大数据,前端,云计算']
])
console.log(result) // 0> {name:xueke, 尚硅谷:Java...}

const m = new Map()
m.set('name', 'ATGUIGU')
const result2 = Object.fromEntries(m)
console.log(result2) // -> name:ATGUIGU

// Object.entries (ES8)
const arr = Object.entries({
  name: '尚硅谷'
})
console.log(arr)
~~~

### 相等性比较唯一数组（intersection）

创建唯一值的数组，这个数组包含所有给定数组都包含的元素，使用[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)进行相等性比较。（注：可以理解为给定数组的交集）

~~~js
_.intersection([2, 1], [4, 2], [1, 2]);
// => [2]
~~~

### 移除指定元素值（pull）

移除数组`array`中所有和给定值相等的元素，使用[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero) 进行全等比较。

~~~js
var array = [1, 2, 3, 1, 2, 3];
_.pull(array, 2, 3);
console.log(array);
// => [1, 1]
~~~

这个方法类似[`_.pull`](https://www.lodashjs.com/docs/lodash.pullAll#pull)，区别是这个方法接收一个要移除值的数组。

~~~js
var array = [1, 2, 3, 1, 2, 3];
_.pullAll(array, [2, 3]);
console.log(array);
// => [1, 1]
~~~

### 根据索引移除元素（pullAt）

根据索引 `indexes`，移除`array`中对应的元素，并返回被移除元素的数组。

~~~js
var array = [5, 10, 15, 20];
var evens = _.pullAt(array, 1, 3);
 
console.log(array);
// => [5, 15]
 
console.log(evens);
// => [10, 20]
~~~

替代方案（array.splice）

### 排序并去重（sortedUniq）

这个方法类似[`_.uniq`](https://www.lodashjs.com/docs/lodash.sortedUniq#uniq)，除了它会优化排序数组。

~~~js
_.sortedUniq([1, 1, 2]);
// => [1, 2]
~~~

### 数组去重（uniq）

创建一个去重后的`array`数组副本。使用了[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero) 做等值比较。只有第一次出现的元素才会被保留。

~~~js
_.uniq([2, 1, 2]);
// => [2, 1]
~~~

## 集合类方法

### 检测是否都为真（every）

通过 `predicate`（断言函数） 检查 `collection`（集合）中的 **所有** 元素是否都返回真值。一旦 `predicate`（断言函数） 返回假值，迭代就马上停止。`predicate`（断言函数）调用三个参数： *(value, index|key, collection)*。

~~~js
_.every([true, 1, null, 'yes'], Boolean);
// => false
 
var users = [
  { 'user': 'barney', 'age': 36, 'active': false },
  { 'user': 'fred',   'age': 40, 'active': false }
];
 
// The `_.matches` iteratee shorthand.
_.every(users, { 'user': 'barney', 'active': false });
// => false
 
// The `_.matchesProperty` iteratee shorthand.
_.every(users, ['active', false]);
// => true
 
// The `_.property` iteratee shorthand.
_.every(users, 'active');
// => false
~~~

### 过滤集合（filter）

~~~js
var users = [
  { 'user': 'barney', 'age': 36, 'active': true },
  { 'user': 'fred',   'age': 40, 'active': false }
];
_.filter(users, function(o) { return !o.active; });
// => objects for ['fred']
~~~

### 遍历集合（forEach）

~~~js
_([1, 2]).forEach(function(value) {
  console.log(value);
});
// => Logs `1` then `2`.
 
_.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
  console.log(key);
});
// => Logs 'a' then 'b' (iteration order is not guaranteed).
~~~

### 检测元素是否存在（includes）

检查 `value`(值) 是否在 `collection`(集合) 中。如果 `collection`(集合)是一个字符串，那么检查 `value`（值，子字符串） 是否在字符串中， 否则使用[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero) 做等值比较。 如果指定 `fromIndex` 是负数，那么从 `collection`(集合) 的结尾开始检索。

~~~js
_.includes([1, 2, 3], 1);
// => true
 
_.includes([1, 2, 3], 1, 2);
// => false
 
_.includes({ 'user': 'fred', 'age': 40 }, 'fred');
// => true
 
_.includes('pebbles', 'eb');
// => true
~~~

### 返回随机元素值（sample）

从`collection`（集合）中获得一个随机元素。

~~~js
_.sample([1, 2, 3, 4]);
// => 2
~~~

### 打乱元素顺序（shuffle）

创建一个被打乱值的集合。 使用[Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle) 版本。

~~~js
_.shuffle([1, 2, 3, 4]);
// => [4, 1, 3, 2]
~~~

### 返回集合长度（size）

返回`collection`（集合）的长度，如果集合是类数组或字符串，返回其 length ；如果集合是对象，返回其可枚举属性的个数。

~~~js
_.size([1, 2, 3]);
// => 3
 
_.size({ 'a': 1, 'b': 2 });
// => 2
 
_.size('pebbles');
// => 7
~~~

